# aPlane Shell Plugin Architecture

## Overview

aPlane Shell features a dual plugin system designed to offer both performance and flexibility. Developers can extend `apshell`'s functionality using either **Core Plugins** (compiled into the binary) or **External Plugins** (which run as separate processes).

| Feature | Core Plugins | External Plugins |
|---|---|---|
| **Language** | Go | Any (Go, Node.js, Python, etc.) |
| **Compilation** | Compiled into the `apshell` binary | Not compiled with `apshell` |
| **Loading** | At compile-time via build tags | At runtime from the filesystem |
| **Communication** | Direct function calls | JSON-RPC over stdin/stdout |
| **Security** | Code is part of the main binary | Process isolation, no direct key access |
| **Use Case** | Tightly-coupled, performance-sensitive features | Flexible, decoupled features, DeFi integrations |

---

## 1. Core Plugins (Compile-Time)

Core plugins are Go packages that are conditionally compiled into the `apshell` binary using Go's build tag system. This provides a way to include or exclude features at build time with zero runtime overhead.

### How They Work

The system relies on a combination of Go build tags, symlinks, and `make` automation.

1.  **Build Tags:** Each core plugin is a Go package that contains a build tag (e.g., `//go:build myplugin`). This tells the Go compiler to only include the file if the `myplugin` tag is provided during the build.
2.  **Symlinks for Activation:** The `coreplugins/` directory contains symlinks to the actual plugin source code located in `coreplugins_repository/`. The presence of a symlink indicates that a plugin is "enabled".
3.  **Makefile Automation:** The `Makefile` scans the `coreplugins/` directory for enabled plugins, generates the necessary Go build tags, and compiles `apshell` with those features included.

### Directory Structure

```
coreplugins_repository/    # Source code for all available core plugins
└── selfping/
    └── selfping.go

coreplugins/               # Symlinks to *enabled* plugins (this dir is gitignored)
└── selfping -> ../coreplugins_repository/selfping

cmd/apshell/                # Auto-generated import files (gitignored)
└── plugin_selfping.go     # Generated by `make generate-plugin-imports`
```

### Available Core Plugins

| Plugin | Tag | Description | Dependencies |
|--------|-----|-------------|--------------|
| **selfping** | `selfping` | Demo plugin - sends zero-ALGO self-payment | None |

**Note:** Both `tinymanswap` and `reti` are available as external plugins for better flexibility and isolation.

### Build Matrix

| Build Target | Build Tags | selfping | Binary Size |
|--------------|-----------|----------|-------------|
| **apshell-core** | (none) | - | ~14M |
| **apshell-all** | (auto-detected) | + | ~14M |

**Legend:**
- `+` Command available (if plugin enabled via symlink)
- `-` Command NOT available

### Build Commands

```bash
# Build with all enabled plugins (default)
make apshell
# or explicitly
make apshell-all

# Build with NO plugins (smallest, core functionality only)
make apshell-core

# Manage plugins
make list-plugins          # List available and active plugins
make enable-selfping       # Enable a plugin (creates symlink)
make disable-selfping      # Disable a plugin (removes symlink)
make disable-all           # Disable all plugins

# Custom build with specific tags
go build -tags "selfping" -o apshell ./cmd/apshell
```

### Compilation Flow

**apshell-core (no tags):**
```
make apshell-core
       |
       v
CGO_ENABLED=1 go build ./cmd/apshell
       |
       v
No -tags flag -> No plugins compiled
       |
       v
Binary: Core commands only
```

**apshell-all (auto-detected tags):**
```
make apshell-all
       |
       v
Scan coreplugins/ for symlinks
       |
       v
Found: selfping -> Generate plugin_selfping.go
       |
       v
CGO_ENABLED=1 go build -tags "selfping" ./cmd/apshell
       |
       v
selfping tag specified -> plugin_selfping.go included
       |
       v
Import coreplugins/selfping -> selfping.go included
       |
       v
init() runs -> Command registered
       |
       v
Binary: Core + selfping command
```

### Creating a Core Plugin

1.  **Create Source Directory:** Create a new directory for your plugin in `coreplugins_repository/`.
    ```bash
    mkdir coreplugins_repository/myplugin
    ```

2.  **Write Plugin Code:** Create a `.go` file with a build tag at the top. The plugin must register itself in an `init()` function.

    ```go
    //go:build myplugin
    // +build myplugin

    package myplugin

    import "github.com/aplane-algo/aplane/internal/command"

    func init() {
        command.RegisterStaticPlugin(&command.Command{
            Name:        "myplugin",
            Description: "My custom plugin",
            Usage:       "myplugin <args>",
            Category:    command.CategoryOrchestration,
            Handler:     &Handler{},
        })
    }

    type Handler struct{}

    func (h *Handler) Execute(args []string, ctx *command.Context) error {
        // Your implementation
        return nil
    }
    ```

3.  **Enable the Plugin:** Use the Makefile to create the symlink.
    ```bash
    make enable-myplugin
    # Creates: coreplugins/myplugin -> ../coreplugins_repository/myplugin
    ```

4.  **Build:** Compile `apshell` with all enabled plugins.
    ```bash
    make apshell-all
    # Automatically generates cmd/apshell/plugin_myplugin.go and builds with the tag
    ```

### Distribution Strategies

**Strategy 1: Core + External Plugins (Recommended)**
Ship `apshell` with core plugins. DeFi functionality via external plugins.

```bash
make apshell-all
```

**Pros:** Simple, DeFi plugins can be updated without recompiling
**Cons:** External plugins need separate installation

**Strategy 2: Core Only**
Ship `apshell-core` for minimal footprint.

```bash
make apshell-core
```

**Pros:** Smallest binary, no plugin overhead
**Cons:** Users must enable plugins manually if needed

### Troubleshooting

**Plugin not showing up:**
1. Added the build tag to the plugin file?
2. Enabled the plugin: `make enable-myplugin`
3. Rebuilt with: `make apshell-all`

Check active plugins:
```bash
make list-plugins
```

**Import file not generated:**
1. Plugin is enabled (symlink exists in `coreplugins/`)?
2. Run `make generate-plugin-imports` to regenerate

### Argument Completion (ArgSpecs)

Plugins can declare their argument types to enable intelligent tab completion. This is done via the `ArgSpecs` field in the Command struct.

**Available Argument Types:**

| Type | Constant | Description | Completion Source |
|------|----------|-------------|-------------------|
| `address` | `ArgTypeAddress` | Algorand address | Signer addresses + alias addresses |
| `asset` | `ArgTypeAsset` | ASA unit name | "algo" + registered ASAs |
| `set` | `ArgTypeSet` | Address set | Set names with @ prefix |
| `keyword` | `ArgTypeKeyword` | Fixed keyword | Values from `Values` field |
| `number` | `ArgTypeNumber` | Numeric value | No completion |
| `file` | `ArgTypeFile` | File path | Filesystem (readline default) |
| `custom` | `ArgTypeCustom` | Plugin-provided | RPC call to plugin (future) |

**Example: Simple address argument**

```go
command.RegisterStaticPlugin(&command.Command{
    Name:        "selfping",
    Description: "Send zero ALGO self-payment",
    Usage:       "selfping <address>",
    Category:    command.CategoryTransaction,
    Handler:     &Handler{},
    ArgSpecs: []command.ArgSpec{
        {Type: command.ArgTypeAddress},
    },
})
```

**Example: Complex multi-argument command**

```go
command.RegisterStaticPlugin(&command.Command{
    Name:        "stake",
    Description: "Stake tokens in a pool",
    Usage:       "stake <action> <amount> <asset> into <pool>",
    Category:    command.CategoryTransaction,
    Handler:     &Handler{},
    ArgSpecs: []command.ArgSpec{
        {Type: command.ArgTypeKeyword, Values: []string{"deposit", "withdraw", "claim"}},
        {Type: command.ArgTypeNumber},
        {Type: command.ArgTypeAsset},
        {Type: command.ArgTypeKeyword, Values: []string{"into", "from"}},
        {Type: command.ArgTypeCustom, Values: []string{"poolid"}}, // Plugin-provided
    },
})
```

**How It Works:**

1. ArgSpecs are read at startup when building the autocompleter
2. When user types `stake <tab>`, the first ArgSpec (`keyword`) provides: `deposit`, `withdraw`, `claim`
3. When user types `stake deposit <tab>`, the second ArgSpec (`number`) provides no completion
4. When user types `stake deposit 100 <tab>`, the third ArgSpec (`asset`) provides: `algo`, `USDC`, etc.
5. Address completion is case-insensitive: typing `peh<tab>` completes to `PEHABC...`

**Conditional Branching:**

For commands with subcommands that have different argument patterns, use branches:

```go
command.RegisterStaticPlugin(&command.Command{
    Name:        "reti",
    Description: "Interact with Reti staking pools",
    Usage:       "reti <subcommand> [args]",
    Category:    command.CategoryTransaction,
    Handler:     &Handler{},
    ArgSpecs: []command.ArgSpec{
        {Type: command.ArgTypeKeyword, Values: []string{"list", "deposit", "withdraw", "balance"}},
        {Branches: []command.ArgBranch{
            {
                When:  command.ArgCondition{Arg: 0, Matches: "^deposit$"},
                Specs: []command.ArgSpec{
                    {Type: command.ArgTypeNumber},
                    {Type: command.ArgTypeKeyword, Values: []string{"into"}},
                    {Type: command.ArgTypeCustom, Values: []string{"validator_id"}},
                },
            },
            {
                When:  command.ArgCondition{Arg: 0, Matches: "^withdraw$"},
                Specs: []command.ArgSpec{
                    {Type: command.ArgTypeNumber},
                    {Type: command.ArgTypeKeyword, Values: []string{"from"}},
                    {Type: command.ArgTypeCustom, Values: []string{"pool_id"}},
                },
            },
            {
                When:  command.ArgCondition{Arg: 0, Matches: "^balance$"},
                Specs: []command.ArgSpec{
                    {Type: command.ArgTypeAddress},
                },
            },
        }},
    },
})
```

This enables context-aware completion:
- `reti deposit 1000 <tab>` → suggests `into`
- `reti withdraw 500 <tab>` → suggests `from`
- `reti balance <tab>` → suggests addresses

### Best Practices

1. **Keep plugins independent** - Each plugin should work standalone
2. **Use meaningful tag names** - Tag name should match plugin name
3. **Test without plugins** - Ensure core functionality works with `make apshell-core`
4. **Use external plugins for complex dependencies** - If your plugin needs Node.js/npm, make it an external plugin instead
5. **Define ArgSpecs** - Always provide ArgSpecs for better user experience with tab completion

### Security Model

The core plugin system is secure because it relies on an explicit, compile-time inclusion model:

1. **Code Review Required** - Plugins must be reviewed and explicitly tagged
2. **No Runtime Loading** - All code compiled into binary at build time
3. **Explicit Selection** - Developer chooses which plugins to include
4. **No Surprises** - Can't accidentally load unwanted code
5. **Static Analysis** - Works across the entire binary

---

## 2. External Plugins (Runtime)

External plugins are standalone executables that run as separate processes and communicate with `apshell` over a JSON-RPC protocol. This provides maximum flexibility, allowing plugins to be written in any language and to be installed or updated without recompiling `apshell`.

### Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Plugin Ecosystem                          │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │ Echo     │  │ Tinyman  │  │  Reti    │  │  Custom  │   │
│  │ Plugin   │  │  Swap    │  │  Stake   │  │  Plugin  │   │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘   │
│       │              │              │              │         │
│       └──────────────┴──────────────┴──────────────┘        │
│                           │ JSON-RPC                         │
└───────────────────────────┼─────────────────────────────────┘
                            ▼
        ┌─────────────────────────────────────┐
        │            apshell                    │
        │  • Plugin discovery & lifecycle      │
        │  • JSON-RPC communication           │
        │  • Transaction intent processing    │
        │  • Parameter resolution             │
        │  • Transaction signing & submission  │
        └──────────────┬──────────────────────┘
                       │
                       ▼
        ┌─────────────────────────────────────┐
        │           apsignerd              │
        │  • Key management                    │
        │  • Transaction signing               │
        └─────────────────────────────────────┘
```

### Plugin Lifecycle

1. **Discovery**: aPlane Shell scans plugin directories at startup
2. **Validation**: Manifests are validated, executables checked
3. **Lazy Loading**: Plugin process spawned when first command is invoked
4. **Initialization**: Plugin receives `initialize` call with network config
5. **Execution**: Plugin processes `execute` calls for commands
6. **Idle**: Plugin remains running between commands
7. **Cleanup**: Plugin receives `shutdown` call when aPlane Shell exits

### Plugin Discovery

Plugins are discovered from the following directories (in order of precedence):

1. `$APSHELL_HOME/plugins/` - Custom location (if APSHELL_HOME is set)
2. `./plugins/` - Current directory plugins
3. `/usr/local/lib/apshell/plugins` - System-wide plugins

Each plugin must reside in its own subdirectory containing:
- `manifest.json` - Plugin manifest
- Executable file (as specified in manifest)
- Any supporting files (libraries, scripts, etc.)

### The Manifest (`manifest.json`)

This file is the entry point for any external plugin.

**Example:**
```json
{
  "name": "my-plugin",
  "version": "1.0.0",
  "description": "My awesome plugin.",
  "author": "Author Name",
  "homepage": "https://github.com/author/plugin",

  "executable": "./my-plugin-executable",
  "args": [],

  "commands": [
    {
      "name": "my-command",
      "description": "Does something awesome.",
      "usage": "my-command <action> <amount> <asset>",
      "examples": ["my-command deposit 100 algo"],
      "category": "defi",
      "arg_specs": [
        {"type": "keyword", "values": ["deposit", "withdraw"]},
        {"type": "number"},
        {"type": "asset"}
      ]
    }
  ],

  "functions": [
    {
      "name": "myPluginDeposit",
      "description": "Deposit assets into the plugin",
      "params": [
        {"name": "amount", "type": "number", "description": "Amount to deposit"},
        {"name": "asset", "type": "asset", "description": "Asset name or ID"},
        {"name": "addr", "type": "address", "description": "Account address or alias"}
      ],
      "returns": "{txid: string, confirmed: boolean}",
      "command": ["deposit", "$amount", "$asset", "for", "$addr"]
    }
  ],

  "networks": ["testnet", "mainnet", "betanet"],
  "timeout": 30,
  "protocol_version": "1.0"
}
```

**Manifest Fields:**

| Field | Required | Default | Description |
|-------|----------|---------|-------------|
| `name` | Yes | - | Unique plugin identifier |
| `version` | Yes | - | Semantic version (e.g., "1.0.0") |
| `description` | Yes | - | Brief description of the plugin |
| `author` | No | - | Plugin author |
| `homepage` | No | - | Plugin homepage URL |
| `executable` | Yes | - | Path to executable (relative to plugin dir, or system command) |
| `args` | No | `[]` | Command-line arguments to pass to the executable |
| `commands` | Yes | - | Array of commands the plugin provides (for CLI and tab completion) |
| `functions` | No | `[]` | Array of typed JS functions (for scripting API - see [Typed Plugin Functions](#typed-plugin-functions)) |
| `networks` | No | all | Networks the plugin supports (empty = all networks) |
| `timeout` | No | 30 | Execution timeout in seconds |
| `protocol_version` | No | "1.0" | JSON-RPC protocol version |

**Note:** The `executable` field can reference:
- A local file: `"./plugin-binary"` or `"./dist/plugin.js"`
- A system command: `"node"` with `"args": ["dist/plugin.js"]`

**Command Fields:**

| Field | Required | Description |
|-------|----------|-------------|
| `name` | Yes | Command name (what user types) |
| `description` | Yes | Brief description shown in help |
| `usage` | Yes | Usage string showing arguments |
| `examples` | No | Array of example invocations |
| `category` | No | Category for help grouping |
| `arg_specs` | No | Array of argument completion specs |

**ArgSpec Fields (for `arg_specs` array):**

| Field | Required | Description |
|-------|----------|-------------|
| `type` | Conditional | One of: `address`, `asset`, `set`, `keyword`, `number`, `file`, `custom`. Required if no `branches`. |
| `values` | No | For `keyword`: array of valid values. For `custom`: completer identifier |
| `branches` | No | Array of conditional branches for context-dependent completion |

**ArgSpec Types:**

| Type | Description | Completion Source |
|------|-------------|-------------------|
| `address` | Algorand address | Signer addresses + alias addresses |
| `asset` | ASA unit name | "algo" + registered ASAs |
| `set` | Address set | Set names with @ prefix |
| `keyword` | Fixed keyword | Values from `values` field |
| `number` | Numeric value | No completion |
| `file` | File path | Filesystem |
| `custom` | Plugin-provided | `complete` RPC call to plugin |

**Conditional Branching:**

For commands with subcommands that have different argument patterns, use `branches`:

```json
{
  "arg_specs": [
    {"type": "keyword", "values": ["deposit", "withdraw", "balance"]},
    {
      "branches": [
        {
          "when": {"arg": 0, "matches": "^deposit$"},
          "specs": [
            {"type": "number"},
            {"type": "keyword", "values": ["into"]},
            {"type": "custom", "values": ["validator_id"]}
          ]
        },
        {
          "when": {"arg": 0, "matches": "^withdraw$"},
          "specs": [
            {"type": "number"},
            {"type": "keyword", "values": ["from"]},
            {"type": "custom", "values": ["pool_id"]}
          ]
        },
        {
          "when": {"arg": 0, "matches": "^balance$"},
          "specs": [
            {"type": "address"}
          ]
        }
      ]
    }
  ]
}
```

**Branch Fields:**

| Field | Description |
|-------|-------------|
| `when.arg` | Argument index to check (0-based) |
| `when.matches` | Regex pattern to match against the argument value |
| `specs` | ArgSpecs to use when condition matches |

### Typed Plugin Functions

Plugins can expose **typed JavaScript functions** that integrate directly into the JS scripting API. Unlike legacy commands (which use string arguments and return `{success, message, data}`), typed functions:

- Have named, typed parameters
- Return data directly (not wrapped)
- Throw exceptions on error (instead of returning `success: false`)
- Are auto-generated as first-class JS functions

This provides a much cleaner scripting experience, allowing code like:
```javascript
// Typed function (preferred)
let balance = retiBalance("alice")
print(balance.totalStaked)

// vs. Legacy command
let r = reti("balance", "alice")
if (r.success) {
    print(r.data.totalStaked)
}
```

#### Function Schema

Add a `functions` array to your manifest alongside `commands`:

```json
{
  "name": "my-plugin",
  "version": "1.0.0",
  "commands": [...],
  "functions": [
    {
      "name": "myPluginDoSomething",
      "description": "Does something useful",
      "params": [
        {"name": "amount", "type": "number", "description": "Amount in ALGO"},
        {"name": "addr", "type": "address", "description": "Account address or alias"}
      ],
      "returns": "{txid: string, confirmed: boolean}",
      "command": ["do-something", "$amount", "for", "$addr"]
    }
  ]
}
```

#### Function Fields

| Field | Required | Description |
|-------|----------|-------------|
| `name` | Yes | JavaScript function name (camelCase, e.g., `retiDeposit`) |
| `description` | Yes | What the function does |
| `params` | Yes | Array of parameter definitions |
| `returns` | Yes | Return type description (for AI and documentation) |
| `command` | Yes | Command template with `$param` placeholders |

#### Parameter Types

| Type | JS Type | Description |
|------|---------|-------------|
| `string` | `string` | Generic string |
| `number` | `number` | Numeric value |
| `address` | `string` | Algorand address or alias (resolved automatically) |
| `asset` | `string \| number` | Asset name (e.g., "usdc") or numeric ID (resolved for current network) |

#### Command Template

The `command` array defines how function parameters map to plugin command arguments. Use `$paramName` for substitution:

```json
{
  "name": "tinymanSwap",
  "params": [
    {"name": "amount", "type": "number"},
    {"name": "fromAsset", "type": "asset"},
    {"name": "toAsset", "type": "asset"},
    {"name": "addr", "type": "address"}
  ],
  "command": ["$amount", "$fromAsset", "to", "$toAsset", "for", "$addr"]
}
```

When called as `tinymanSwap(100, "usdc", "algo", "alice")`, this generates the command:
```
["100", "usdc", "to", "algo", "for", "alice"]
```

#### Complete Example: Reti Staking Plugin

```json
{
  "name": "reti-plugin",
  "version": "1.0.0",
  "description": "Reti staking pool plugin for depositing and withdrawing ALGO",
  "executable": "node",
  "args": ["dist/reti-plugin.js"],

  "commands": [
    {
      "name": "reti",
      "description": "Interact with Reti staking pools",
      "usage": "reti list | pools <id> | deposit <amt> algo into <pool> for <addr> | withdraw <amt> algo from <pool> for <addr> | balance <addr>",
      "category": "defi"
    }
  ],

  "functions": [
    {
      "name": "retiList",
      "description": "List all available Reti staking validators",
      "params": [],
      "returns": "{validators: [{id: number, name: string, commission: number, totalStaked: number}]}",
      "command": ["list"]
    },
    {
      "name": "retiBalance",
      "description": "Get Reti staking balance for an account",
      "params": [
        {"name": "addr", "type": "address", "description": "Account address or alias"}
      ],
      "returns": "{stakes: [{poolAppId: number, validatorId: number, balance: number}], totalStaked: number}",
      "command": ["balance", "$addr"]
    },
    {
      "name": "retiDeposit",
      "description": "Deposit ALGO into a Reti validator",
      "params": [
        {"name": "amount", "type": "number", "description": "Amount of ALGO to stake"},
        {"name": "validatorId", "type": "number", "description": "Validator ID to deposit into"},
        {"name": "addr", "type": "address", "description": "Account address or alias"}
      ],
      "returns": "{txids: string[], validatorId: number, poolAppId: number}",
      "command": ["deposit", "$amount", "algo", "into", "$validatorId", "for", "$addr"]
    },
    {
      "name": "retiWithdraw",
      "description": "Withdraw ALGO from a Reti staking pool",
      "params": [
        {"name": "amount", "type": "number", "description": "Amount of ALGO to unstake"},
        {"name": "poolAppId", "type": "number", "description": "Pool App ID to withdraw from"},
        {"name": "addr", "type": "address", "description": "Account address or alias"}
      ],
      "returns": "{txids: string[], poolAppId: number, withdrawAmount: string}",
      "command": ["withdraw", "$amount", "algo", "from", "$poolAppId", "for", "$addr"]
    }
  ],

  "networks": ["testnet", "mainnet"],
  "timeout": 120
}
```

#### How It Works

1. **Discovery**: At startup, `apshell` discovers plugins and parses their manifests
2. **Registration**: For each function in `manifest.functions`, a JS wrapper is auto-generated
3. **Execution**: When the JS function is called:
   - Parameters are validated (count check)
   - `$param` placeholders in `command` are substituted with actual values
   - The plugin's `execute` RPC method is called with the generated args
   - On success, `result.data` is returned directly
   - On failure, an exception is thrown

#### AI Integration

Typed functions are automatically included in the AI prompt with TypeScript-style signatures:

```
PLUGIN FUNCTIONS:
External plugin functions for DeFi and other operations. These are first-class JS functions.
- Return data directly (not wrapped in {success, message, data})
- Throw on error (use try/catch if needed)
- Asset parameters accept names like 'usdc' or numeric IDs (resolved for current network)
- Address parameters accept aliases like 'alice' or full Algorand addresses

- retiList(): {validators: [{id: number, name: string, commission: number, totalStaked: number}]}
  List all available Reti staking validators
- retiBalance(addr: string /* address or alias */): {stakes: [...], totalStaked: number}
  Get Reti staking balance for an account
- retiDeposit(amount: number, validatorId: number, addr: string /* address or alias */): {txids: string[], ...}
  Deposit ALGO into a Reti validator
- tinymanSwap(amount: number, fromAsset: string | number /* asset name or ID */, toAsset: string | number, addr: string): {...}
  Swap tokens using Tinyman AMM
```

This helps the AI generate clean, idiomatic code that uses the typed functions correctly.

#### Migration from Legacy Commands

If your plugin currently only has `commands`, you can add `functions` alongside them:

1. Keep existing `commands` for backward compatibility and tab completion
2. Add `functions` array with typed function definitions
3. Function names should be descriptive (e.g., `retiBalance` not just `balance`)
4. The same plugin `execute` handler processes both interfaces

Plugins with typed functions will have their legacy commands hidden from the AI prompt to avoid confusion, but they remain available for direct command-line use.

### JSON-RPC Protocol

Plugins communicate with aPlane Shell using JSON-RPC 2.0 over stdin/stdout.

#### initialize

Called once after the plugin starts.

**Request:**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "network": "testnet",
    "apiServer": "https://testnet-api.algonode.cloud",
    "apiToken": "",
    "indexerUrl": "https://testnet-idx.algonode.cloud",
    "version": "1.0"
  }
}
```

**Response:**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "success": true,
    "message": "Plugin initialized",
    "version": "1.0.0"
  }
}
```

#### execute

Called to run a specific command.

**Request:**
```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "execute",
  "params": {
    "command": "command-name",
    "args": ["arg1", "arg2"],
    "context": {
      "accounts": ["ADDR1...", "ADDR2..."],
      "assetMap": {"USDC": 10458941, "ALGO": 0},
      "addressMap": {"alice": "ADDR1...", "bob": "ADDR2..."},
      "network": "testnet",
      "round": 12345,
      "genesisId": "testnet-v1.0",
      "genesisHash": "SGO1GKSzyE...",
      "suggestedParams": {
        "fee": 1000,
        "firstValid": 12345,
        "lastValid": 12445,
        "genesisID": "testnet-v1.0",
        "genesisHash": "SGO1GKSzyE..."
      },
      "continuation": {}
    }
  }
}
```

**Response (informational):**
```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "success": true,
    "message": "Command executed successfully",
    "data": {"key": "value"}
  }
}
```

**Response (with transactions):**
```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "success": true,
    "message": "Swap quote: 1.5 USDC for 10 ALGO",
    "transactions": [
      {
        "type": "raw",
        "encoded": "gqNzaWfEQE...",
        "description": "Tinyman swap transaction"
      }
    ],
    "requiresApproval": true,
    "data": {
      "pool_address": "POOL...",
      "amount_in": "10000000",
      "amount_out_expected": "1500000"
    }
  }
}
```

#### getInfo

Returns metadata about the plugin.

**Request:**
```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "getInfo",
  "params": {}
}
```

**Response:**
```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "name": "plugin-name",
    "version": "1.0.0",
    "description": "Plugin description",
    "author": "Author",
    "commands": ["command1", "command2"],
    "networks": ["testnet", "mainnet"],
    "status": "ready"
  }
}
```

#### shutdown

Notifies the plugin to exit gracefully.

**Request:**
```json
{
  "jsonrpc": "2.0",
  "id": 4,
  "method": "shutdown",
  "params": {}
}
```

**Response:**
```json
{
  "jsonrpc": "2.0",
  "id": 4,
  "result": {
    "success": true,
    "message": "Plugin shutdown"
  }
}
```

#### complete (Optional)

Called when tab completion is needed for a `custom` type ArgSpec. Only required if the plugin uses `"type": "custom"` in its arg_specs.

**Request:**
```json
{
  "jsonrpc": "2.0",
  "id": 5,
  "method": "complete",
  "params": {
    "name": "poolid",
    "partial": "abc",
    "context": {
      "network": "testnet",
      "command": "stake",
      "args": ["deposit", "100", "algo", "into"]
    }
  }
}
```

**Response:**
```json
{
  "jsonrpc": "2.0",
  "id": 5,
  "result": {
    "suggestions": ["abc123-pool", "abc456-pool", "abc789-pool"]
  }
}
```

**Parameters:**

| Field | Description |
|-------|-------------|
| `name` | The completer identifier from ArgSpec `values` field |
| `partial` | What the user has typed so far (may be empty) |
| `context.network` | Current network |
| `context.command` | The command being completed |
| `context.args` | Arguments typed so far |

**Note:** This method is optional. If not implemented, custom ArgSpecs will provide no completion suggestions.

### Execution Context

aPlane Shell provides rich context to plugins via the `context` field:

| Field | Type | Description |
|-------|------|-------------|
| `accounts` | `[]string` | List of all available account addresses (addresses that can sign) |
| `assetMap` | `map[string]uint64` | ASA name → asset ID mapping (includes both Name and UnitName) |
| `addressMap` | `map[string]string` | Alias → address mapping |
| `network` | `string` | Current network (testnet, mainnet, betanet) |
| `round` | `uint64` | Current round number |
| `genesisId` | `string` | Network genesis ID |
| `genesisHash` | `string` | Network genesis hash |
| `suggestedParams` | `object` | Transaction parameters from network |
| `continuation` | `map[string]any` | Continuation context for multi-step workflows |

**Parameter Resolution (Priority Order):**

1. **ASA Names → Asset IDs**: Plugin receives `assetMap` with ASA name/unit name → asset ID mappings
   - Example: `{"USDC": 10458941, "ALGO": 0}`
   - Case-insensitive lookup recommended

2. **Aliases → Addresses**: Plugin receives `addressMap` with alias → address mappings
   - Example: `{"alice": "ALICE_ADDRESS...", "bob": "BOB_ADDRESS..."}`

### Transaction Intents

Plugins propose transactions by returning transaction intents in the execute response.

**TransactionIntent Fields:**

```go
type TransactionIntent struct {
    Type        string                 `json:"type"`        // payment, asset-transfer, app-call, raw
    From        string                 `json:"from,omitempty"`
    To          string                 `json:"to,omitempty"`
    Amount      uint64                 `json:"amount,omitempty"`
    AssetID     uint64                 `json:"assetId,omitempty"`
    AppID       uint64                 `json:"appId,omitempty"`
    AppArgs     [][]byte               `json:"appArgs,omitempty"`
    Note        []byte                 `json:"note,omitempty"`
    Encoded     string                 `json:"encoded,omitempty"` // Base64-encoded raw transaction
    Description string                 `json:"description"`       // Human-readable description
    Metadata    map[string]interface{} `json:"metadata,omitempty"`
}
```

**Transaction Intent Types:**

| Type | Description | Required Fields |
|------|-------------|-----------------|
| `raw` | Fully-formed transaction | `encoded`, `description` |
| `payment` | Simple ALGO payment | `from`, `to`, `amount` |
| `asset-transfer` | ASA transfer | `from`, `to`, `amount`, `assetId` |
| `app-call` | Application call | `from`, `appId`, `appArgs` |

### Multi-Step Workflows (Continuations)

For complex protocols that require multiple transaction submissions with confirmations between steps, plugins can use the continuation mechanism.

**Example Response with Continuation:**
```json
{
  "success": true,
  "message": "STEP 1: Create deposit escrow",
  "transactions": [
    {"type": "raw", "encoded": "...", "description": "Create escrow"}
  ],
  "requiresApproval": true,
  "continuation": {
    "command": "my-plugin",
    "args": ["_internal_step2", "arg1"],
    "context": {
      "escrowAddress": "ESCROW_ADDR...",
      "step2Data": "..."
    },
    "message": "Step 1 completed. Proceeding to Step 2..."
  }
}
```

**Continuation Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `command` | string | The plugin command to execute next |
| `args` | []string | Arguments for the next step |
| `context` | map | State to pass to the next step via `params.context.continuation` |
| `message` | string | Optional message to display before executing the next step |

**Execution Flow:**
1. Plugin returns Step 1 transactions + continuation
2. aPlane Shell submits Step 1, waits for confirmation
3. aPlane Shell automatically calls the continuation command
4. Continuation context is available in `params.context.continuation`
5. Plugin returns Step 2 transactions + continuation (or final result)
6. Process repeats until no continuation is returned

### Local Signers (Plugin-Controlled Keys)

Some DeFi protocols require plugins to control ephemeral accounts or escrow keys that aren't managed by the user's apsignerd keystore. For example, a lending protocol might create a temporary escrow account for each deposit operation.

In these cases, plugins can return `localSigners` in the response `data` field to indicate which accounts should be signed locally by apshell rather than sent to apsignerd.

**Format:**
```json
{
  "success": true,
  "message": "Deposit into lending pool",
  "transactions": [...],
  "requiresApproval": true,
  "data": {
    "localSigners": [
      {
        "address": "ESCROW_ADDRESS_1...",
        "secretKey": "base64-encoded-64-byte-ed25519-secret-key"
      },
      {
        "address": "ESCROW_ADDRESS_2...",
        "secretKey": "base64-encoded-64-byte-ed25519-secret-key"
      }
    ],
    "amount": 10.5
  }
}
```

**How It Works:**

1. Plugin generates transactions that include some from plugin-controlled accounts
2. Plugin returns the secret keys for those accounts in `localSigners`
3. apshell identifies which transactions need local vs server signing:
   - Transactions from `localSigners` addresses → signed locally by apshell
   - All other transactions → sent to apsignerd for signing
4. apshell handles group orchestration (dummy transactions, fee distribution, group ID)
5. Final signed group is submitted to the network

**Security Notes:**

- Local signer keys are ephemeral and protocol-specific (e.g., deposit escrows)
- Keys are only held in memory during transaction signing
- The `localSigners` field is automatically filtered from response data shown to users
- User's main account keys remain securely in apsignerd

**⚠️ Important Disclaimer:**

Keys supplied by plugins are **not trusted, audited, sandboxed, policy-enforced, or protected by aPlane**. aPlane makes no guarantees about their safety, usage, or scope.

Transactions signed with plugin-supplied keys are **outside aPlane's security guarantees** and are executed entirely at the plugin/operator's risk.

**Use Cases:**

- Lending protocols with per-user escrow accounts
- DEX protocols with ephemeral swap accounts
- Multi-step workflows where intermediate accounts are created and used

### Error Codes

**Standard JSON-RPC Error Codes:**

| Code | Constant | Description |
|------|----------|-------------|
| -32700 | ParseError | Invalid JSON |
| -32600 | InvalidRequest | Invalid request object |
| -32601 | MethodNotFound | Method not found |
| -32602 | InvalidParams | Invalid parameters |
| -32603 | InternalError | Internal error |

**Custom aPlane Shell Error Codes:**

| Code | Constant | Description |
|------|----------|-------------|
| -32000 | PluginError | Generic plugin error |
| -32001 | NetworkError | Network request failed |
| -32002 | AuthenticationError | Authentication failed |
| -32003 | InsufficientFunds | Not enough balance |
| -32004 | InvalidAddress | Invalid Algorand address |
| -32005 | TransactionFailed | Transaction submission failed |

### Transaction Processing Flow

1. Plugin returns transaction intents in execute response
2. aPlane Shell processes intents:
   - Decodes raw transactions from base64 → msgpack
   - Validates transaction structure
3. User approval (if `requiresApproval: true`)
4. aPlane Shell signs transactions via Signer
5. aPlane Shell submits transactions to network
6. Transaction IDs displayed to user

### Creating an External Plugin

1. **Choose a Language:** Any language that can read from stdin, write to stdout, and handle JSON.

2. **Implement the JSON-RPC Server:** Listen for JSON-RPC requests on stdin and send responses to stdout.

3. **Implement Required Methods:** `initialize`, `execute`, `getInfo`, `shutdown`

4. **Create a Manifest:** Write a `manifest.json` file.

5. **Install the Plugin:** Copy your plugin's directory to one of the plugin search paths (e.g., `./plugins/` or `$APSHELL_HOME/plugins/`).

**Example: Simple Echo Plugin (Go)**

```go
package main

import (
    "bufio"
    "encoding/json"
    "os"
)

type Request struct {
    JSONRPC string                 `json:"jsonrpc"`
    ID      interface{}            `json:"id"`
    Method  string                 `json:"method"`
    Params  map[string]interface{} `json:"params"`
}

type Response struct {
    JSONRPC string      `json:"jsonrpc"`
    ID      interface{} `json:"id"`
    Result  interface{} `json:"result"`
}

func main() {
    scanner := bufio.NewScanner(os.Stdin)
    encoder := json.NewEncoder(os.Stdout)

    for scanner.Scan() {
        var req Request
        if err := json.Unmarshal(scanner.Bytes(), &req); err != nil {
            continue
        }

        var result interface{}
        switch req.Method {
        case "initialize":
            result = map[string]interface{}{
                "success": true,
                "message": "Echo plugin initialized",
                "version": "1.0.0",
            }
        case "execute":
            args := req.Params["args"].([]interface{})
            message := ""
            for _, arg := range args {
                message += arg.(string) + " "
            }
            result = map[string]interface{}{
                "success": true,
                "message": "Echo: " + message,
            }
        case "getInfo":
            result = map[string]interface{}{
                "name":        "echo-plugin",
                "version":     "1.0.0",
                "description": "Simple echo plugin",
                "commands":    []string{"echo"},
                "status":      "ready",
            }
        case "shutdown":
            result = map[string]interface{}{
                "success": true,
                "message": "Shutdown",
            }
            encoder.Encode(Response{JSONRPC: "2.0", ID: req.ID, Result: result})
            os.Exit(0)
        }

        encoder.Encode(Response{JSONRPC: "2.0", ID: req.ID, Result: result})
    }
}
```

### Environment Variables

Plugins receive these environment variables when started:

| Variable | Description |
|----------|-------------|
| `ALGOSH_NETWORK` | Current network (testnet, mainnet, betanet) |
| `ALGOSH_API_SERVER` | Algorand node API URL |
| `ALGOSH_API_TOKEN` | API token if configured |
| `ALGOSH_INDEXER_URL` | Indexer URL |
| `ALGOSH_PLUGIN` | Set to "1" to indicate plugin context |

### Development Guidelines

**Manifest Best Practices:**
1. Use semantic versioning
2. Declare minimum required networks
3. Set appropriate timeouts (network operations need more time)
4. Provide detailed command descriptions and examples

**Protocol Implementation:**
1. Implement all four required methods
2. Always respond with matching request ID
3. Use `jsonrpc: "2.0"` in all responses
4. Flush stdout after each response
5. Log errors to stderr (not stdout)

**Parameter Resolution:**
1. Check `assetMap` first for ASA name → ID resolution (case-insensitive)
2. Check `addressMap` second for alias → address resolution
3. Validate addresses before use
4. Return clear error messages for unknown aliases/assets

**Transaction Generation:**
1. Use `type: "raw"` with base64-encoded msgpack transactions
2. Set `requiresApproval: true` for transactions requiring user confirmation
3. Provide clear `description` for each transaction
4. Include metadata in `data` field for user information
5. Ensure transactions use correct network genesis ID/hash from context

### Plugin Directory Layout

```
plugins/my-plugin/
├── manifest.json          # Plugin manifest
├── my-plugin              # Executable (compiled binary)
├── package.json           # If Node.js plugin
├── node_modules/          # Dependencies (if needed)
└── README.md              # Plugin documentation
```

### Example Plugins

Example plugins are available in `examples/external_plugins/`:

| Plugin | Language | Description | Typed Functions |
|--------|----------|-------------|-----------------|
| **echo-plugin** | Go | Simple demonstration plugin | `echoMessage()`, `echoTx()` |
| **tinymanswap** | Node.js/TypeScript | Tinyman DEX integration | `tinymanSwap()` |
| **reti** | Node.js/TypeScript | Reti staking pools | `retiList()`, `retiPools()`, `retiDeposit()`, `retiWithdraw()`, `retiBalance()` |

All example plugins include typed function definitions for seamless JavaScript integration.

To use an example plugin, copy it to one of the discovery paths:
```bash
cp -r examples/external_plugins/echo-plugin ./plugins/
```

### Security Model

**OS-Level Sandboxing:**

External plugins run in OS-level sandboxes that restrict filesystem access. This prevents malicious or compromised plugins from accessing sensitive data.

| Platform | Technology | Status |
|----------|------------|--------|
| Linux | [bubblewrap](https://github.com/containers/bubblewrap) | Required (`apt install bubblewrap`) |
| macOS | sandbox-exec (Seatbelt) | Built-in |
| Windows | Not supported | Use WSL2 (runs Linux sandbox) |

**Sandboxing is mandatory.** If the sandbox is unavailable (e.g., bubblewrap not installed on Linux), plugins will not run.

**What plugins CAN access:**
- `/usr`, `/lib`, `/lib64`, `/bin`, `/sbin` (read-only) - system binaries and libraries
- `/etc/ssl`, `/etc/ca-certificates` (read-only) - TLS certificates
- `/etc/resolv.conf`, `/etc/hosts`, `/etc/nsswitch.conf` (read-only) - DNS resolution
- Plugin directory (read-only) - the plugin's own files
- `/tmp` (read-write) - temporary files
- Network - required for algod/indexer API calls

**What plugins CANNOT access:**
- `~/.ssh` - SSH keys
- `~/.aws` - AWS credentials
- `~/.gnupg` - GPG keys
- `~/.config` - application configs
- User home directory (except plugin dir if located there)
- Any path not explicitly mounted

**Sensitive environment variables filtered:**
- `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_SESSION_TOKEN`
- `GITHUB_TOKEN`, `GH_TOKEN`, `NPM_TOKEN`
- `SSH_AUTH_SOCK`, `SSH_AGENT_PID`, `GPG_AGENT_INFO`

**Linux Sandbox Details (bubblewrap):**

Plugins run in isolated namespaces:
- User namespace (`--unshare-user`)
- PID namespace (`--unshare-pid`)
- IPC namespace (`--unshare-ipc`)
- UTS namespace (`--unshare-uts`)
- Cgroup namespace (`--unshare-cgroup`)
- Network is shared (plugins need algod/indexer access)

The sandbox dies with the parent process (`--die-with-parent`), preventing orphaned sandboxed processes.

**macOS Sandbox Details (Seatbelt):**

Uses dynamically generated Seatbelt profiles with `sandbox-exec`. The profile:
- Denies all access by default (`(deny default)`)
- Explicitly allows required paths and operations
- Blocks sensitive home directory paths

**Verifying Sandbox Status:**

When a plugin starts, you'll see:
```
[plugin-name] Running in sandbox (bubblewrap (Linux))
```
or
```
[plugin-name] Running in sandbox (sandbox-exec (macOS))
```

**Process Isolation:**
- Plugins run as separate subprocesses
- Cannot access aPlane Shell memory or keys
- Communication only via stdin/stdout

**No Direct Key Access:**
- Plugins cannot sign transactions
- Only propose transaction intents
- aPlane Shell/Signer performs all signing

**User Approval:**
- Transactions with `requiresApproval: true` require user confirmation
- User sees decoded transaction details before approval

**Resource Limits:**
- Timeout enforcement (default 30s)
- Process cleanup on timeout or error

**Integrity Verification:**
- All plugins must include `checksums.sha256` with SHA256 hashes
- Executable must be listed in checksums
- Checksums verified at discovery time

### Future Enhancements

1. **Enhanced Security**
   - GPG signature validation
   - Plugin allowlist system

2. **Advanced Features**
   - Plugin registry/marketplace
   - Dependency management
   - Process pooling for performance

3. **Developer Tools**
   - Plugin scaffolding CLI
   - Testing framework
   - Debug mode

---

## 3. Plugin Development Guidelines

This section outlines best practices for developing robust external plugins.

### Handle Network Changes

**Important:** Users can switch networks (mainnet, testnet, betanet) at any time during a session. Plugins must handle this correctly.

The network is provided in two places:
1. **Initialization** (`initialize` method): `params.network` - the network when the plugin started
2. **Execution** (`execute` method): `context.network` - the current network for this command

**Problem:** If a plugin only uses the initialization network, it will use the wrong network after the user switches. For example, resolving mainnet USDC (31566704) on testnet will fail with a 404 error.

**Solution:** Always check `context.network` in your execute handler and update if changed:

```javascript
// JavaScript example
async function handleExecute(params) {
    const context = params.context || {};

    // Check if network changed since initialization
    if (context.network && context.network !== pluginState.network) {
        logInfo(`Network changed: ${pluginState.network} -> ${context.network}`);
        pluginState.network = context.network;
        // Reinitialize network-specific resources if needed (API clients, app IDs, etc.)
    }

    // ... rest of execute logic
}
```

```go
// Go example
func handleExecute(params ExecuteParams) (*ExecuteResult, error) {
    if params.Context.Network != "" && params.Context.Network != pluginState.Network {
        log.Printf("Network changed: %s -> %s", pluginState.Network, params.Context.Network)
        pluginState.Network = params.Context.Network
        // Reinitialize network-specific resources
    }

    // ... rest of execute logic
}
```

### Asset Resolution

The `context.assetMap` provides ASA name → asset ID mappings. Note:
- **ALGO is NOT in the assetMap** - it's the native currency, not an ASA
- Plugins should handle "ALGO" or "algo" natively (typically asset ID 0)
- Asset IDs are network-specific (e.g., USDC is 31566704 on mainnet, 10458941 on testnet)

```javascript
// Handle ALGO specially
function resolveAssetId(assetIdentifier, assetMap) {
    if (assetIdentifier.toLowerCase() === 'algo') {
        return 0; // ALGO is always asset ID 0
    }

    // Check assetMap for ASA names
    if (assetMap && assetMap[assetIdentifier]) {
        return assetMap[assetIdentifier];
    }

    // Try parsing as numeric asset ID
    const parsed = parseInt(assetIdentifier);
    if (!isNaN(parsed)) {
        return parsed;
    }

    throw new Error(`Unknown asset: ${assetIdentifier}`);
}
```

### Address Resolution

The `context.addressMap` provides alias → address mappings. Always resolve aliases before using addresses:

```javascript
function resolveAddress(input, addressMap) {
    // Check if it's already an address (58-char base32)
    if (/^[A-Z2-7]{58}$/.test(input)) {
        return input;
    }

    // Try alias lookup
    if (addressMap && addressMap[input]) {
        return addressMap[input];
    }

    throw new Error(`Unknown account: ${input}`);
}
```

### Error Handling

- Return clear error messages that help users understand what went wrong
- Include the operation that failed and any relevant IDs (asset IDs, addresses)
- For network errors, indicate if it might be a network mismatch issue

### Testing Across Networks

Always test your plugin on multiple networks:
1. Start on testnet, run commands
2. Switch to mainnet (`network mainnet`), run the same commands
3. Switch back to testnet, verify it still works

---

## See Also

- [coreplugins_repository/README.md](../coreplugins_repository/README.md) - Core plugin development guide
- [examples/external_plugins/README.md](../examples/external_plugins/README.md) - External plugin examples
- [Makefile](../Makefile) - All available build targets
